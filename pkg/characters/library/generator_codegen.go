//go:build ignore
// +build ignore

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
	"text/template"
)

// CharacterDef holds parsed character information
type CharacterDef struct {
	ConstName   string // CharacterSa
	Name        string // "sam"
	ColorConst  string // ColorSa
	Color       string // "#FF0000"
	Comment     string // "Shadja (Red)"
	Description string // "sam - Musical note avatar (Pure Red)"
}

// ThemeDef holds theme information
type ThemeDef struct {
	Name        string            // "bright", "latte", "garden", "cozy"
	Number      int               // 1, 2, 3, 4
	Description string            // Theme description
	ColorConsts map[string]string // CharacterSa -> Theme1ColorSa
}

const characterTemplate = `// Code generated by generator_codegen.go; DO NOT EDIT.

package library

func init() {
	register(GenerateFromRegistry(CharacterMetadata{
		Name:        {{.ConstName}},
		Description: "{{.Description}}",
		Author:      "Wildreason, Inc",
		Color:       {{.ColorConst}},
		Width:       11,
		Height:      4,
	}))
}
`

const themesTemplate = `// Code generated by generator_codegen.go; DO NOT EDIT.

package library

// Theme initialization - register all themes
func init() {
{{- range .Themes}}
	// Theme {{.Number}}: {{.Name | title}}
	registerTheme(ThemeDefinition{
		Name:        "{{.Name}}",
		Description: "{{.Description}}",
		Colors: map[string]string{
{{- range $charConst, $themeColorConst := .ColorConsts}}
			{{$charConst}}: {{$themeColorConst}},
{{- end}}
		},
	})
{{end -}}
}
`

func main() {
	verify := flag.Bool("verify", false, "Verify mode: check if generated files match existing")
	flag.Parse()

	// Parse constants.go
	characters, themes, err := parseConstants("constants.go")
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing constants.go: %v\n", err)
		os.Exit(1)
	}

	// Validate
	if err := validate(characters, themes); err != nil {
		fmt.Fprintf(os.Stderr, "Validation failed: %v\n", err)
		os.Exit(1)
	}

	if *verify {
		if err := verifyGenerated(characters, themes); err != nil {
			fmt.Fprintf(os.Stderr, "Generated files are out of date: %v\n", err)
			fmt.Fprintf(os.Stderr, "\nRun: make generate\n")
			os.Exit(1)
		}
		return
	}

	// Generate character files
	for _, char := range characters {
		if err := generateCharacterFile(char); err != nil {
			fmt.Fprintf(os.Stderr, "Error generating %s.go: %v\n", char.Name, err)
			os.Exit(1)
		}
		fmt.Printf("Generated %s.go\n", char.Name)
	}

	// Generate themes file
	if err := generateThemesFile(themes); err != nil {
		fmt.Fprintf(os.Stderr, "Error generating themes_generated.go: %v\n", err)
		os.Exit(1)
	}
	fmt.Println("Generated themes_generated.go")
}

func parseConstants(filename string) ([]CharacterDef, []ThemeDef, error) {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filename, nil, parser.ParseComments)
	if err != nil {
		return nil, nil, fmt.Errorf("parse file: %w", err)
	}

	var characters []CharacterDef
	charNames := make(map[string]string)    // CharacterSa -> "sam"
	charColors := make(map[string]string)   // ColorSa -> "#FF0000"
	themeColors := make(map[string]string)  // Theme1ColorSa -> "#FF0000"
	themeDescs := make(map[string]string)   // "bright" -> description
	charComments := make(map[string]string) // CharacterSa -> "Shadja (Red)"

	// First pass: extract all constants
	for _, decl := range node.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok || genDecl.Tok != token.CONST {
			continue
		}

		// Get comment for const block
		var blockComment string
		if genDecl.Doc != nil && len(genDecl.Doc.List) > 0 {
			blockComment = strings.TrimSpace(genDecl.Doc.List[0].Text)
			blockComment = strings.TrimPrefix(blockComment, "//")
			blockComment = strings.TrimSpace(blockComment)
		}

		for _, spec := range genDecl.Specs {
			valueSpec, ok := spec.(*ast.ValueSpec)
			if !ok || len(valueSpec.Names) == 0 || len(valueSpec.Values) == 0 {
				continue
			}

			name := valueSpec.Names[0].Name
			value := extractStringValue(valueSpec.Values[0])

			// Get inline comment
			var comment string
			if valueSpec.Comment != nil && len(valueSpec.Comment.List) > 0 {
				comment = strings.TrimSpace(valueSpec.Comment.List[0].Text)
				comment = strings.TrimPrefix(comment, "//")
				comment = strings.TrimSpace(comment)
			}

			// Categorize constants
			if strings.HasPrefix(name, "Character") {
				charNames[name] = value
				charComments[name] = comment
			} else if strings.HasPrefix(name, "Color") && !strings.Contains(name, "Theme") {
				charColors[name] = value
			} else if strings.HasPrefix(name, "Theme") && strings.Contains(name, "Color") {
				themeColors[name] = value
			}

			// Extract theme descriptions from block comments
			if strings.HasPrefix(blockComment, "Theme") {
				// Parse "Theme 1: Original Bright (description)"
				re := regexp.MustCompile(`Theme \d+: ([^(]+) \(([^)]+)\)`)
				matches := re.FindStringSubmatch(blockComment)
				if len(matches) == 3 {
					themeName := strings.ToLower(strings.TrimSpace(matches[1]))
					themeName = strings.ReplaceAll(themeName, " ", "")
					// Map friendly names
					if themeName == "originalbright" {
						themeName = "bright"
					} else if themeName == "lattewindow" {
						themeName = "latte"
					} else if themeName == "gardenterminal" {
						themeName = "garden"
					} else if themeName == "cozyworkspace" {
						themeName = "cozy"
					}
					desc := matches[2]
					themeDescs[themeName] = desc
				}
			}
		}
	}

	// Second pass: build character definitions
	charOrder := []string{"CharacterSa", "CharacterRi", "CharacterGa", "CharacterMa", "CharacterPa", "CharacterDa", "CharacterNi"}
	for _, constName := range charOrder {
		name, ok := charNames[constName]
		if !ok {
			continue
		}

		// Extract suffix (Sa, Ri, etc.)
		suffix := strings.TrimPrefix(constName, "Character")
		colorConst := "Color" + suffix
		color := charColors[colorConst]
		comment := charComments[constName]

		// Extract color name from comment (e.g., "Shadja (Red)" -> "Red")
		colorName := "Unknown"
		if idx := strings.Index(comment, "("); idx != -1 {
			colorName = strings.TrimSuffix(strings.TrimPrefix(comment[idx:], "("), ")")
		}

		characters = append(characters, CharacterDef{
			ConstName:   constName,
			Name:        name,
			ColorConst:  colorConst,
			Color:       color,
			Comment:     comment,
			Description: fmt.Sprintf("%s - Musical note avatar (%s)", name, colorName),
		})
	}

	// Third pass: build theme definitions
	themeNames := []string{"bright", "latte", "garden", "cozy"}
	var themes []ThemeDef
	for i, themeName := range themeNames {
		themeNum := i + 1
		theme := ThemeDef{
			Name:        themeName,
			Number:      themeNum,
			Description: themeDescs[themeName],
			ColorConsts: make(map[string]string),
		}

		// Map each character to its theme color constant
		for _, constName := range charOrder {
			if _, ok := charNames[constName]; !ok {
				continue
			}
			suffix := strings.TrimPrefix(constName, "Character")
			themeColorConst := fmt.Sprintf("Theme%dColor%s", themeNum, suffix)
			theme.ColorConsts[constName] = themeColorConst
		}

		themes = append(themes, theme)
	}

	return characters, themes, nil
}

func extractStringValue(expr ast.Expr) string {
	lit, ok := expr.(*ast.BasicLit)
	if !ok || lit.Kind != token.STRING {
		return ""
	}
	// Remove quotes
	return strings.Trim(lit.Value, `"`)
}

func validate(characters []CharacterDef, themes []ThemeDef) error {
	if len(characters) == 0 {
		return fmt.Errorf("no characters found")
	}
	if len(themes) == 0 {
		return fmt.Errorf("no themes found")
	}

	// Validate character names
	seen := make(map[string]bool)
	for _, char := range characters {
		if seen[char.Name] {
			return fmt.Errorf("duplicate character name: %s", char.Name)
		}
		seen[char.Name] = true

		if !isValidHexColor(char.Color) {
			return fmt.Errorf("invalid color for %s: %s", char.Name, char.Color)
		}
	}

	// Validate themes have all characters
	for _, theme := range themes {
		if len(theme.ColorConsts) != len(characters) {
			return fmt.Errorf("theme %s has %d characters, expected %d",
				theme.Name, len(theme.ColorConsts), len(characters))
		}
	}

	return nil
}

func isValidHexColor(color string) bool {
	matched, _ := regexp.MatchString(`^#[0-9A-Fa-f]{6}$`, color)
	return matched
}

func generateCharacterFile(char CharacterDef) error {
	tmpl := template.Must(template.New("char").Parse(characterTemplate))

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, char); err != nil {
		return err
	}

	filename := fmt.Sprintf("%s.go", char.Name)
	return os.WriteFile(filename, buf.Bytes(), 0644)
}

func generateThemesFile(themes []ThemeDef) error {
	funcMap := template.FuncMap{
		"title": strings.Title,
	}
	tmpl := template.Must(template.New("themes").Funcs(funcMap).Parse(themesTemplate))

	// Sort character constants for consistent output
	for i := range themes {
		themes[i].ColorConsts = sortedMap(themes[i].ColorConsts)
	}

	data := struct {
		Themes []ThemeDef
	}{
		Themes: themes,
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return err
	}

	return os.WriteFile("themes_generated.go", buf.Bytes(), 0644)
}

func sortedMap(m map[string]string) map[string]string {
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	sorted := make(map[string]string, len(m))
	for _, k := range keys {
		sorted[k] = m[k]
	}
	return sorted
}

func verifyGenerated(characters []CharacterDef, themes []ThemeDef) error {
	tmpDir, err := os.MkdirTemp("", "tangent-verify-*")
	if err != nil {
		return fmt.Errorf("create temp dir: %w", err)
	}
	defer os.RemoveAll(tmpDir)

	// Save current dir
	origDir, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("get working dir: %w", err)
	}

	// Generate to temp dir
	if err := os.Chdir(tmpDir); err != nil {
		return fmt.Errorf("chdir to temp: %w", err)
	}
	defer os.Chdir(origDir)

	// Generate files
	for _, char := range characters {
		if err := generateCharacterFile(char); err != nil {
			return fmt.Errorf("generate %s.go: %w", char.Name, err)
		}
	}
	if err := generateThemesFile(themes); err != nil {
		return fmt.Errorf("generate themes: %w", err)
	}

	// Compare with existing files
	for _, char := range characters {
		filename := fmt.Sprintf("%s.go", char.Name)
		if err := compareFiles(filepath.Join(tmpDir, filename), filepath.Join(origDir, filename)); err != nil {
			return fmt.Errorf("%s: %w", filename, err)
		}
	}

	if err := compareFiles(
		filepath.Join(tmpDir, "themes_generated.go"),
		filepath.Join(origDir, "themes_generated.go"),
	); err != nil {
		return fmt.Errorf("themes_generated.go: %w", err)
	}

	return nil
}

func compareFiles(expected, actual string) error {
	expectedBytes, err := os.ReadFile(expected)
	if err != nil {
		return fmt.Errorf("read expected: %w", err)
	}

	actualBytes, err := os.ReadFile(actual)
	if err != nil {
		return fmt.Errorf("read actual: %w", err)
	}

	if !bytes.Equal(expectedBytes, actualBytes) {
		return fmt.Errorf("files differ")
	}

	return nil
}
